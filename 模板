//-------------------------------字符串哈希-------------------------------
acwing：核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ ){
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r){
    return h[r] - h[l - 1] * p[r - l + 1];
}

//-----------------------高精度算法----------------------
// 高精度算法，数组存储：从低位-->高位
// 高精度加法，满足C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B){
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ ){
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

//高精度减法，满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B){
    vector<int> c;
    
    for(int i = 0, t = 0; i < A.size(); i ++){
        t += A[i];
        if(i < B.size())t -= B[i];
        c.push_back((t + 10) % 10);
        if(t < 0)t = -1;
        else t = 0;
    }
    
    while(c.back() == 0 && c.size() > 1)c.pop_back();
    return c;
}

// 高精度乘法，高精度×低精度，// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b){
    vector<int> C;

    for (int i = 0, t = 0; i < A.size() || t; i ++ ){
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

//高精度除法，高精度÷低精度，
//A >= 0, b > 0, A除b余r
vector<int> div(vector<int> &A, int b, int &r){
    vector<int> C;  r = 0;
    
    for (int i = A.size() - 1; i >= 0; i -- ){
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

//-------------------------------差分矩阵-------------------------------

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c

//-------------------------------KMP-------------------------------

void getnext(){//求给定子串p的next数组，记录前后缀相等的长度
    nex[0] = nex[1] = 0;
    int n = strlen(p + 1);
    for(int i = 2; i <= n; i ++){
        int j = nex[i - 1];
        while(j && p[i] != p[j + 1])j = nex[j];
        nex[i] = (p[i] == p[j + 1]) ? j + 1 : 0;
    }
}

void kmp(){//查询在字符串p在s中的出现次数ans
    int j = nex[1], ans = 0;
    int m = strlen(s + 1);
    for(int i = 1; i <= m; i ++){
        while(j && s[i] != p[j + 1])j = nex[j];
        if(s[i] == p[j + 1])j ++;
        if(j == n)ans ++;
    }
}

//-------------------------------Trie树-------------------------------

int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

//-------------------------------AC自动机-------------------------------
const int maxn = 1e5 + 10;
int tree[maxn][26],fail[maxn];
int sum[maxn], tot, n, m, ans[1100];
char s[2000010], p[1100][55];

void insert(int k){
    int rt = 0;
    for(int i = 0; p[k][i]; i ++){
        int a = p[k][i] - 'A';
        if(!tree[rt][a])tree[rt][a] = ++ tot;
        rt = tree[rt][a];        
    }
    sum[rt] = k;
}

int q[maxn];

void build(){// 生成fail指针
    int hh = 0, tt = -1;
    for(int i = 0; i < 26; i ++){
        if(tree[0][i])q[++ tt] = tree[0][i];
    }
    while(hh <= tt){
        int a =q[hh ++];
        for(int i = 0; i < 26; i ++){
            if(tree[a][i])fail[tree[a][i]] = tree[fail[a]][i], q[++ tt] = tree[a][i];
            else tree[a][i] = tree[fail[a]][i];
        }
    }
}

for(int i = 0, rt = 0; s[i]; i ++){// 记录各目标字符串的次数
    int a = s[i] - 'A';
    if(a >= 26 || a < 0){rt = 0; continue;}
    rt = tree[rt][a];
    for(int j = rt; j; j = fail[j]){
        if(sum[j])ans[sum[j]] ++;
    }
}

for(int i = 1; i <= n; i ++){
    if(ans[i])printf("%s: %d\n", p[i], ans[i]);
}

//-------------------------------主席树-------------------------------

// 可持久化线段树（主席树）求静态区间[l,r]第k大，可持久化线段树模板
// 求区间第k大，需离散化处理，然后不断更新得到不同版本的线段树，然后将r版本的线段树减去l-1版本的线段树得到另一线段树，在此线段树上求区间第k大

const int maxn = 1e5 + 10;
struct  node{
    int l, r, v;
}t[maxn << 5];
int s[maxn], a[maxn], n, m, root[maxn], tot;

int bulid(int l, int r){// 建树
    //新建结点
    int rt = ++ tot;
    t[rt].v = 0;

    if(l == r)return rt;
    int mid = l + r >> 1;
    // 左右儿子序号
    t[rt].l = bulid(l, mid), t[rt].r = bulid(mid + 1, r);
    
    return rt;
}

int update(int node, int l, int r, int pos){// 更新线段树版本，最后返回更新后的当前版本的根结点序号（单点更新）
    // 线段树更新时，在当前需更新位置新建结点，初始时新建左右儿子不变，值加1
    int rt = ++ tot;
    t[rt] = t[node], t[rt].v ++;
    
    if(l == r)return rt;//更新结束

    int mid = l + r >> 1;
    //若更新位置在左边区间，则左儿子变化（否则右儿子变化）
    if(pos <= mid)t[rt].l = update(t[rt].l, l, mid, pos);
    else t[rt].r = update(t[rt].r, mid + 1, r, pos);

    return rt;
}

int query(int a, int b, int l, int r, int k){//查询区间[a + 1, b]第k大
    if(l == r)return l;
    // 对当前区间[l, r]，求[l, l + r >> 1]内元素个数
    int sum = t[t[b].l].v - t[t[a].l].v, mid = l + r >> 1;
    //若k小于sum，则第k大在左边区间内，否则在右边区间[l + r >> 1 + 1, r]上找第k - sum大元素
    if(sum >= k)return query(t[a].l, t[b].l, l, mid, k);
    else return query(t[a].r, t[b].r, mid + 1, r, k - sum);
}   

void init(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++)scanf("%d", &s[i]), a[i] = s[i];
    //离散化
    sort(s + 1, s + n + 1);
    int q = unique(s + 1, s + n + 1) - s - 1;
    
    root[0] = bulid(1, q);
    
    for(int i = 1; i <= n; i ++){
        int pos = lower_bound(s + 1, s + q + 1, a[i]) - s;
        root[i] = update(root[i - 1], 1, q, pos);//在前一版本线段树上更新，得到当前版本的根结点序号
    }
   
    while(m --){
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        int id = query(root[l - 1], root[r], 1, q, k);//区间[l,r]第k大元素在离散化数组下标
        printf("%d\n", s[id]);
    }
}

//-------------------------------二维线段树-------------------------------

// 二维线段树 建树O(n^2) 查询O（logn ^ 2）
const int maxn = 1e3 + 10;
#define lson rt << 1 
#define rson rt << 1 | 1

ll t[maxn << 2][maxn << 2];
int n;

void rebuild(int rt, int l, int r, int num){
    t[num][rt] = 0;
    if(l == r)return ;
    int mid = l + r >> 1;
    rebuild(lson, l, mid, num), rebuild(rson, mid + 1, r, num);
}

void build(int rt, int l, int r){
    rebuild(1, 1, n, rt);
    if(l == r)return;
    int mid = l + r >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
}

void reupdate(int rt, int l, int r, int y, int num, int d){
    if(l == r)return void(t[num][rt] += d);
    int mid = l + r >> 1;
    if(y <= mid)reupdate(lson, l, mid, y, num, d);
    else reupdate(rson, mid + 1, r, y, num, d);
    t[num][rt] = t[num][lson] + t[num][rson];
}

void update(int rt, int l, int r, int x, int y, int d){
    reupdate(1, 1, n, y, rt, d);
    if(l == r)return;
    int mid = l + r >> 1;
    if(x <= mid)update(lson, l, mid, x, y, d);
    else update(rson, mid + 1, r, x, y, d);
}

ll requery(int rt, int l, int r, int Y1, int Y2, int num){
    if(Y1 <= l && r <= Y2)return t[num][rt];
    int mid = l + r >> 1;
    ll ret = 0;
    if(Y1 <= mid)ret += requery(lson, l, mid, Y1, Y2, num);
    if(mid < Y2)ret += requery(rson, mid + 1, r, Y1, Y2, num);
    return ret;
}

ll query(int rt, int l, int r, int X1, int Y1, int X2, int Y2){
    if(X1 <= l && r <= X2)return requery(1, 1, n, Y1, Y2, rt);
    int mid = l + r >> 1;
    ll ret = 0;
    if(X1 <= mid)ret += query(lson, l, mid, X1, Y1, X2, Y2);
    if(mid < X2)ret += query(rson, mid + 1, r, X1, Y1, X2, Y2);
    return ret;
}

//-------------------------------二维树状数组-------------------------------
const int maxn = 1e3 + 10;
int t[maxn][maxn], n;

void update(int x, int y){
    while(x <= n){
        int dy = y;
        while(dy <= n)t[x][dy] += 1, dy += lowbit(dy);
        x += lowbit(x);
    }
}

int getsum(int x, int y){
    int ret = 0;
    while(x){
        int dy = y;
        while(dy)ret += t[x][dy], dy -= lowbit(dy);
        x -= lowbit(x);
    }
    return ret;
}

//-------------------------------树链剖分-------------------------------

树链剖分操作：
1.对子树所有结点求和
2.对子树所有结点进行更新
3.对任意两点间的路径上所有点求和
4.对任意两点间的路径上所有点进行更新
// 树链剖分 ：把一棵树拆成若干个不相交的链，然后用数据结构去维护这些链

struct node{
    int to, next;
}s[maxn];
int tree[maxn << 2], lazy[maxn << 2];
int head[maxn], tot, cnt, w[maxn], mod, n, m, r;
int son[maxn], fa[maxn], sz[maxn], d[maxn], top[maxn], id[maxn], wt[maxn];

//根据dfs序进行线段树区间求和, 区间修改(子树修改及求和)

void pushdown(int rt, int len){
    if(lazy[rt]){
        lazy[lson] += lazy[rt], lazy[rson] += lazy[rt];
        tree[lson] += lazy[rt] * ((len - (len >> 1)) % mod) % mod;
        tree[rson] += lazy[rt] * ((len >> 1) % mod) % mod;
        lazy[lson] %= mod, lazy[rson] %= mod;
        tree[lson] %= mod, tree[rson] %= mod;
        lazy[rt] = 0;
    }
}

void build(int l, int r, int rt){
    if(l == r)return void(tree[rt] = wt[l]);
    int mid = l + r >> 1;
    build(l, mid, lson), build(mid + 1, r, rson);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

void update(int l, int r, int L, int R, int rt, int y){
    if(L <= l && r <= R){
        lazy[rt] = (lazy[rt] + y) % mod;
        tree[rt] += y % mod * ((r - l + 1) % mod) % mod;
        return ;
    }
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1;
    if(L <= mid)update(l, mid, L, R, lson, y);
    if(mid < R)update(mid + 1, r, L, R, rson, y);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

int query(int l, int r, int L, int R, int rt){
    if(L <= l && r <= R)return tree[rt];
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1, ret = 0;
    if(L <= mid)ret = (ret + query(l, mid, L, R, lson)) % mod;
    if(mid < R)ret = (ret + query(mid + 1, r, L, R, rson)) % mod;
    return ret;
}

//树链剖分(两点间修改及求和)

void dfs1(int u, int pre){// 第一次遍历，找每个点的重儿子
    // 记录深度、子树大小、父亲结点
    d[u] = d[pre] + 1, sz[u] = 1, fa[u] = pre;
    // 记录重儿子子树大小
    int mson = -1;
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre)continue;
        dfs1(to, u);
        sz[u] += sz[to];
        if(sz[to] > mson)son[u] = to, mson = sz[to];// 记录每个结点重儿子位置及子树大小
    }
}

void dfs2(int u, int pre, int topx){//第二次遍历，生成dfs序，将树剖分为不相关的链
    id[u] = ++ cnt, wt[cnt] = w[u];
    top[u] = topx;
    // 记录dfs序、 每个点所在链的顶端结点
    if(!son[u])return ;
    dfs2(son[u], u, topx);
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre || to == son[u])continue;
        dfs2(to, u, to);// 轻儿子，存在一条从轻儿子开始的链，顶端结点为本身
    }
}

int qlink(int a, int b){// 两点间查询
    int ret = 0;
    while(top[a] != top[b]){// 当两点不在一条链上
        if(d[top[a]] < d[top[b]])swap(a, b);// 把a变为深度大的那一点, 再求链上的权值和
        ret = (ret + query(1, n, id[top[a]], id[a], 1)) % mod;// 对[a的顶端结点, a]求和
        a = fa[top[a]];// a变为a的顶端结点的父节点
    }
    if(d[a] < d[b])swap(a, b);// 属于同一条链, 直接求和
    ret = (ret + query(1, n, id[b], id[a], 1)) % mod;
    return ret;
}

void uplink(int a, int b, int y){// 两点间更新
    while(top[a] != top[b]){
        if(d[top[a]] < d[top[b]])swap(a, b);
        update(1, n, id[top[a]], id[a], 1, y);
        a = fa[top[a]];
    }
    if(d[a] < d[b])swap(a, b);
    update(1, n, id[b], id[a], 1, y);
}

//-------------------------------树上启发式合并-------------------------------

// 树上启发式合并处理某些树上离线问题，复杂度O（nlogn）统计节点子树出现颜色种数
// sz: 子树大小 big: 重儿子
// col: 结点颜色 Node[i]: DFS 序为 i 的结点
// L[u]: 结点 u 的 DFS 序
// R[u]: 结点 u 子树中结点的 DFS 序的最大值
// Node[i]: DFS 序为 i 的结点 ans: 存答案
// cnt[i]: 颜色为 i 的结点个数
// totColor: 目前出现过的颜色个数

const int N = 2e5 + 5;
int n, sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;
vector<int> g[N];

void add(int u) {
    if (cnt[col[u]] == 0) ++totColor;
    cnt[col[u]]++;
}
void del(int u) {
    cnt[col[u]]--;
    if (cnt[col[u]] == 0) --totColor;
}

void dfs0(int u, int p) {
    L[u] = ++ totdfn;
    Node[totdfn] = u;
    sz[u] = 1;
    for (int v : g[u]){
        if (v != p) {
            dfs0(v, u);
            sz[u] += sz[v];
            if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
        }
    }
    R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
    // 计算轻儿子的答案
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            dfs1(v, u, false);
        }
    }
    // 计算重儿子答案并保留计算过程中的数据（用于继承）
    if (big[u]) {
        dfs1(big[u], u, true);
    }
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            // 子树结点的 DFS 序构成一段连续区间，可以直接遍历
            for (int i = L[v]; i <= R[v]; i++) {
                add(Node[i]);
            }
        }
    }
    add(u);
    ans[u] = totColor;
    if (keep == false) {
        for (int i = L[u]; i <= R[u]; i++) {
            del(Node[i]);
        }
    }
}

void init() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs0(1, 0);
    dfs1(1, 0, false);
    for (int i = 1; i <= n; i++) printf("%d%c", ans[i], " \n"[i == n]);
}

//-------------------------------Treap(普通平衡树)-------------------------------

Treap操作：
1.插入数值 x。
2.删除数值 x(若有多个相同的数，应只删除一个)。
3.查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4.查询排名为 x 的数值。
5.求数值 x 的前驱(前驱定义为小于 x 的最大的数)。
6.求数值 x 的后继(后继定义为大于 x 的最小的数)

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 2e6 + 10;

struct node{
	int l, r;
	int size, cnt;
	int k, val;
}tr[maxn * 5];
int idx, root;

int newnode(int k){
	tr[++ idx].k = k;
	tr[idx].cnt = tr[idx].size = 1;
	tr[idx].val = rand();
	return idx;
}

void pushup(int u){
	tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + tr[u].cnt;
}

void yx(int &u){
	int q = tr[u].l;
	tr[u].l = tr[q].r;
	tr[q].r = u;
	u = q;
	pushup(tr[u].r);
	pushup(u);
}

void zx(int &u){
	int q = tr[u].r;
	tr[u].r = tr[q].l;
	tr[q].l = u;
	u = q;
	pushup(tr[u].l);
	pushup(u);
}

void build(){
	newnode(-inf), newnode(inf);
	root = 1, tr[1].r = 2;
	pushup(root);
	if(tr[1].val < tr[2].val)zx(root);
}

void insert(int &u, int k){
	if(u == 0)u = newnode(k);
	else{
		if(k == tr[u].k)tr[u].cnt ++;
		else{
			if(k < tr[u].k){
				insert(tr[u].l, k);
				if(tr[tr[u].l].val > tr[u].val)yx(u);
			}
			else {
				insert(tr[u].r, k);
				if(tr[tr[u].r].val > tr[u].val)zx(u);
			}
		}
	}
	pushup(u);
}

int getpre(int u, int k){
	if(u == 0)return -inf;
	if(tr[u].k >= k)return getpre(tr[u].l, k);
	else return max(tr[u].k, getpre(tr[u].r, k));
}

int getnex(int u, int k){
	if(u == 0)return inf;
	if(tr[u].k <= k)return getnex(tr[u].r, k);
	else return min(tr[u].k, getnex(tr[u].l, k));
}


int main(){
	build();
	int n;
	ll ans = 0;
	scanf("%d", &n);
	scanf("%d", &ans);
	insert(root, ans);
	for(int i = 2; i <= n; i ++){
	    int x;
	    scanf("%d", &x);
	    int a = getnex(root, x), b = getpre(root, x);
	    if(a == inf)a = 0;
	    if(b == -inf)b = 0;
	    ans += min(abs(a - x),abs(b - x));
		insert(root, x);
	}
	printf("%lld", ans);
	return 0;
}

//-------------------------------逆元-------------------------------
  
//1.费马小定理,a的逆元为a的mod-2次方，条件：mod为质数，且mod与a互质
const int mod = 1e9 + 7;
ll qpow(ll a,ll b){
    ll ret = 1;
    while(b){
        if(b&1)//奇数
            ret = (ret * a) % mod;
        b >>= 1;
        a = (a * a) % mod;
    }
    return ret;
}

//2.拓展欧几里得定理，条件：n与mod互质，但mod可以不为质数
void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
}

ll Inv(ll n) {
    ll x, y;
    exgcd(n, mod, x, y);
    x = (x + mod) % mod;
    return x;//n的逆元
}

//3.线性递推求1~n逆元
//由k*i+r=p(mod p)推出inv[i]=-(mod/i)*inv[mod%i]%mod;
void Inv(int n){
    int inv[100000];
    inv[1] = 1;
    for (int i = 2; i < mod; ++i)
    inv[i] = (mod - mod / i) * inv[mod % i] % mod;//保证为正数 
}

//4.求阶乘逆元
//inv[i+1]为(i+1)!的逆元
//由inv[i+1]*(i+1)=inv[i]
void Inv(int n){
    int inv[10000];
    int k;
    inv[n+1] = k;//n!的逆元，可由费马小定理求得
    for (int i = n; i >= 1;i--)
        inv[i] = inv[i + 1] * (i + 1);
}

//-------------------------------线性基-------------------------------

ll s[maxn], n, p[maxn];
void solvex(){//求集合s的线性基，数组p存放集合s的线性基
    for(int i = 1; i <= n; i ++){
        ll a = s[i];
        for(int j = 60; j >= 0; j --){
            if(a & (1ll << j)){
                if(!p[j]){p[j] = a; break;}
                else a ^= p[j];
            }
        }
    }
}

ll solvemaxx(){// 求集合s异或最大值
    ll ans = 0;
    for(int i = 60; i >= 0; i --){
        if((ans ^ p[i]) > ans) ans = ans ^ p[i];
    }
    return ans;
}

//-------------------------------欧拉函数-------------------------------

//n的欧拉函数值
int oula(int n){
    int ans = n;
    for(int i = 2; 1ll * i * i <= n; i ++){
      if(n % i == 0){
      ans -= ans/i;
      while(n % i == 0)n /= i;
      }
    }
    if(n != 1)ans -= ans/n;
	return ans;
}


//线性筛求欧拉函数 O(n)
void getoula(){
    memset(vis, 1, sizeof vis);
    vis[1] = 0, sum[1] = 1;
    for(int i = 2; i <= maxn; i ++){
        if(vis[i])p[++ tot] = i, sum[i] = i - 1;//存欧拉函数值
        for(int j = 1; j <= tot && i * p[j] <= maxn; j ++){
            vis[i * p[j]] = 0;
            if(i % p[j] == 0){
                sum[i * p[j]] = p[j] * sum[i];
                break;
            }
            sum[i * p[j]] = (p[j] - 1) * sum[i];
        }
    }
}

//-------------------------------拓展欧几里得-------------------------------

// 求一组x, y 使得 ax + by = gcd(a, b)

void exgcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return ;
    }
    exgcd(b, a % b, x, y);
    int  t = x;
    x = y;
    y = t - a / b * y;
}

//-------------------------------勒让德定理+卢卡斯定理-------------------------------

// 勒让德定理：求阶乘质数因子
int cal(int n,int p)
{
    if(n==0)//n为0时退出
        return 0;
    return n / p + cal(n / p, p);
}

// 卢卡斯定理：求大组合数
ll C(ll a, ll b, ll p){}//求组合数

ll lucas(ll a, ll b, ll p){
    if(a < p && b < p)return C(a, b, p);//组合数，此时a，b都小于p， 可用费马小定理求逆元，进而求组合数
    return C(a % p, b % p, p) % p * lucas(a / p, b / p, p) % p;//p为质数
}

//-------------------------------Pollard Rho 算法/Miller-Rabin素数测试-------------------------------
Miller-Rabin素数测试：
快速判断一个1e18范围内的数是否为素数，对其进行Miller-Rabin素数测试;
可以大概率判断其是否为素数，出错的概率为1/4的k次方，k为测试次数。故当测试次数越多，其出错概率越小。

寻找n最大的质因子(n<1e18)：
ll n, m, ans;

ll gcd(ll a, ll b){return b == 0 ? a : gcd(b, a % b);}

ll qmul(ll a, ll b, ll p){//快速乘
    ll z = (long double)a / p * b;
    // long double 换成 double 会 TLE 两个点 ？？？
    ll ret = (ull)a * b - (ull)z * p;
    return (ret + p) % p;
}

ll qpow(ll a, ll b, ll p){//快速幂
    ll ret = 1;
    while(b){
        if(b & 1)ret = qmul(ret , a , p);
        b >>= 1;
        a = qmul(a, a, p);
    }
    return ret;
}

bool Miller_rabin(ll n){// Miller _ Rabin判断素数
    if(n == 2)return true;
    if(n < 2 || !(n & 1))return false;//特判
    ll m = n - 1, k = 0;
    while(!(m & 1))m >>= 1, k ++;// 求得2的幂次数
    for(int i = 1; i <= 6; i ++){// 测试次数
        ll a = rand() % (n - 1) + 1;// 随机生成a
        ll x = qpow(a, m, n), y;
        for(int j = 1; j <= k; j ++){
            y = qmul(x, x, n);
            if(y == 1 && x != 1 && x != n - 1)return false;
            // a ^ 2 = 1(mod p), p为质数，若a不为 1或者 n - 1， 则不符合二次探测定理
            x = y;
        }
        if(y != 1)return false;// 费马小定理的逆命题判断
    }
    return true;
}

ll Pollard_Rho(ll n){// 二次优化，减少了gcd的计算次数
    ll z, x, y, g, c;
    while(1){// 一定会找到一个因子
        int i = 0, j = 1;
        c = rand() % (n - 1) + 1;
        y = x = rand() % (n - 1) + 1;// 随机初始化
        z = 1;// 存 abs(x - y)的乘积
        while(++ i){
            x = (qmul(x, x, n) + c) % n;// x ^ 2 + c
            z = qmul(z, abs(x - y), n);
            if(!z || x == y)break; // z = 0时重新测试， x == y时即为跑完了环，也重新测试
            if(i == j || i % 127 == 0){// 当i == j 或者 i % 127 = 0 时，判断gcd
                g = gcd(n, z);
                if(g > 1)return g;// 找到了一个因子
                if(i == j)j <<= 1, y = x; // 倍增维护答案准确性
            }
        } 
    }
}

void pr(ll n){
    if(n <= ans)return; // 剪枝
    if(Miller_rabin(n)){ans = n; return ;}
    ll a = Pollard_Rho(n);
    while(n % a == 0)n /= a;
    pr(a), pr(n); // 继续分解
}

//-------------------------------卡特兰数-------------------------------

给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：
Cat(n) = C(2n, n) / (n + 1)

//-------------------------------数论分快-------------------------------

一维数论分块
int init(){
  int ans = 0;
    for(int l = 1, r; l <= n; l = r + 1){
        r = n/(n/l);
        ans += (n/l) * (r - l + 1); 
    }
    return ans;
}

二维数论分块
int init(){
    int ans = 0;
    for(int l = 1, r; l <= min(n, m); l = r + 1){
        r = min(n/(n/l), m/(m/l));
        ans += (n/l) * (m/l) * (r - l + 1); 
    }
    return ans;
}

//-------------------------------FFT-------------------------------

const double PI = acos(-1.0);

struct Complex {
    double x, y;
    Complex(double _x = 0.0, double _y = 0.0){
        x = _x, y = _y;
    }
    Complex operator - (const Complex &b) const {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator + (const Complex &b) const {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator * (const Complex &b) const {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 *len 必须为 2 的幂
 */
void change(Complex y[], int len) {
    int i, j, k;
    for (int i = 1, j = len/2; i < len - 1; i++) {
        if (i < j) swap(y[i], y[j]);
        // 交换互为小标反转的元素，i<j 保证交换一次
        // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
        k = len / 2;
        while(j >= k){
            j = j - k, k = k / 2;
        }
        if (j < k) j += k;
    }
}
/*
 * 做 FFT
 *len 必须是 2^k 形式
 *on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
    change(y, len);
    for (int h = 1; h <= len; h <<= 1) {
        Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));
        for (int j = 0; j < len; j += h) {
            Complex w(1, 0);
            for (int k = j; k < j + h / 2; k++) {
                Complex u = y[k];
                Complex t = w * y[k + h / 2];
                y[k] = u + t;
                y[k + h / 2] = u - t;
                w = w * wn;
            }
        }
    }
    if(on == -1){
        for (int i = 0; i < len; i++)y[i].x /= len;
    }
}

//-------------------------------spfa-------------------------------
时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                if (!st[j]) {    // 如果队列中已存在j，则不需要将j重复插入
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

//spfa判负环
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中
// 如果存在负环，则返回true，否则返回false。
bool spfa(){
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    queue<int> q;
    for (int i = 1; i <= n; i ++ ){
        q.push(i);
        st[i] = true;
    }
    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

//-------------------------------匈牙利算法-------------------------------

int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过
bool find(int x){
    for (int i = h[x]; i != -1; i = ne[i]){
        int j = e[i];
        if (!st[j]){
            st[j] = true;
            if (match[j] == 0 || find(match[j])){
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}
// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ ){
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}

//-------------------------------染色法判断二分图-------------------------------

struct node{
    int to, next;
}s[maxn];
int n, m, tot, head[maxn];
int c[maxn];

void add(int u, int v){
    s[++ tot].to = v;
    s[tot].next = head[u];
    head[u] = tot;
}

bool dfs(int a, int b){
    c[a] = b;
    for(int i = head[a]; ~i; i = s[i].next){
        int to = s[i].to;
        if(c[to] == b)return false;
        if(c[to] == 0 && !dfs(to, -b))return false;
    }
    return true;
}

bool init(){
    memset(c, 0, sizeof c);
    memset(head, -1, sizeof head);
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i ++){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }    
    int flag = dfs(1, 1);
    if(n & 1)flag = false;
    return flag;//true为真
}

//-------------------------------dinic算法（最大流）-------------------------------
struct node{
    int to, next, w;
}e[maxn];
int head[maxn], tot = -1;
int n, m, dep[maxn], s, t, q[maxn];

void add(int u, int v, int w){
    e[++ tot].to = v;
    e[tot].next = head[u];
    e[tot].w = w;
    head[u] = tot;
}

bool bfs(){//多路增广分层，返回是否搜到了汇点
    memset(dep, 0, (n + 1) * sizeof(int));
    int hh = 0, tt = -1;
    q[++ tt] = s, dep[s] = 1;
    while(hh <= tt){
        int u = q[hh ++];
        for(int i = head[u]; ~i; i = e[i].next){
            int to = e[i].to;
            if(e[i].w && !dep[to])//按有残量的边搜过去
                dep[to] = dep[u] + 1, q[++ tt] = to;
        }
    }
    return dep[t];//dep[t]是否为0确定是否搜到了汇点
}

ll dfs(int u, ll in){//in为u收到的流量
    if(u == t)return in;//汇点收到的流量
    ll out = 0;
    for(int i = head[u]; ~i; i = e[i].next){
        int to = e[i].to;
        if(e[i].w && dep[to] == dep[u] + 1){//仅允许流往下一层
            int ret = dfs(to, min(in, 1ll * e[i].w));
            // ret为u真正输出到汇点的流量
            e[i].w -= ret, e[i ^ 1].w += ret;
            in -= ret, out += ret;
        }
    }
    //若out为0，则u与汇点不相通，上一层不必再流往u
    if(out == 0)dep[u] = 0;
    return out;
}

ll dinic(){
    memset(head, -1, sizeof head);
    int a, b, c;
    while(m --){
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, 0);
    }
    ll ans = 0;
    while(bfs())ans += dfs(s, 1e18);
    return ans;
}
