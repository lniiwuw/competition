2.字符串处理

2.1 字符串哈希
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ull;
// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
ull h[maxn], p[maxn];
// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ ){
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ull get(int l, int r){
    return h[r] - h[l - 1] * p[r - l + 1];
}

2.2 KMP

//求给定子串p的next数组，记录前后缀相等的长度
void getnext(){
    nex[0] = nex[1] = 0;
    int n = strlen(p + 1);
    for(int i = 2; i <= n; i ++){
        int j = nex[i - 1];
        while(j && p[i] != p[j + 1])j = nex[j];
        nex[i] = (p[i] == p[j + 1]) ? j + 1 : 0;
    }
}

//查询在字符串p在s中的出现次数ans
void kmp(){
    int j = nex[1], ans = 0;
    int m = strlen(s + 1);
    for(int i = 1; i <= m; i ++){
        while(j && s[i] != p[j + 1])j = nex[j];
        if(s[i] == p[j + 1])j ++;
        if(j == n)ans ++;
    }
}


2.3 AC自动机
求多个模式串分别在文本串中的出现次数

const int maxn = 2e6 + 10;

int tree[maxn][26], fail[maxn], sum[maxn];
int in[maxn], mp[maxn];
int n, len, tot;
char s[maxn], s1[2 * maxn];

// 插入
void insert(int k){
    int rt = 0;
    for(int i = 1; i <= len; i ++){
        int a = s1[i] - 'a';
        if(!tree[rt][a])tree[rt][a] = ++ tot;
        rt = tree[rt][a];
    }
    mp[k] = rt;
}

// 生成fail指针
void build(){
    queue<int> q;
    for(int i = 0; i < 26; i ++){
        if(tree[0][i])q.push(tree[0][i]);
    }
    while(q.size()){
        int a = q.front(); q.pop();
        for(int i = 0; i < 26; i ++){
            int b = tree[a][i];
            if(!b){tree[a][i] = tree[fail[a]][i]; continue;}
            fail[b] = tree[fail[a]][i];
            q.push(b);
            in[fail[b]] ++;//拓扑排序入度
        }
    }
}

// 拓扑排序优化
void topo(){
    queue<int> q;
    for(int i = 1; i <= tot; i ++){
        if(in[i] == 0)q.push(i);
    }
    while(q.size()){
        int a = q.front(); q.pop();
        int b = fail[a];
        in[b] --;
        sum[b] += sum[a];
        if(in[b] == 0)q.push(b);
    }
}

int main(){
    int t, q, x, y;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        scanf("%s", s1 + 1);
        len = strlen(s1 + 1);
        insert(i);
    }
    scanf("%s", s + 1);
    build();
    int rt = 0;
    len = strlen(s + 1);
    for(int i = 1; i <= len; i ++){
        int a = s[i] - 'a';
        rt = tree[rt][a];
        sum[rt] ++;
    }
    topo();
    for(int i = 1; i <= n; i ++)printf("%d\n", sum[mp[i]]);
    return 0;
}
