1.1 二维线段树
//建树O(n^2) 查询O（logn ^ 2） 区间查询(x1,y1)×(x2,y2)矩形内元素和

const int maxn = 1e3 + 10;
#define lson rt << 1 
#define rson rt << 1 | 1

ll t[maxn << 2][maxn << 2];
int n;

void rebuild(int rt, int l, int r, int num){
    t[num][rt] = 0;
    if(l == r)return ;
    int mid = l + r >> 1;
    rebuild(lson, l, mid, num), rebuild(rson, mid + 1, r, num);
}

void build(int rt, int l, int r){
    rebuild(1, 1, n, rt);
    if(l == r)return;
    int mid = l + r >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
}

void reupdate(int rt, int l, int r, int y, int num, int d){
    if(l == r)return void(t[num][rt] += d);
    int mid = l + r >> 1;
    if(y <= mid)reupdate(lson, l, mid, y, num, d);
    else reupdate(rson, mid + 1, r, y, num, d);
    t[num][rt] = t[num][lson] + t[num][rson];
}

void update(int rt, int l, int r, int x, int y, int d){
    reupdate(1, 1, n, y, rt, d);
    if(l == r)return;
    int mid = l + r >> 1;
    if(x <= mid)update(lson, l, mid, x, y, d);
    else update(rson, mid + 1, r, x, y, d);
}

ll requery(int rt, int l, int r, int Y1, int Y2, int num){
    if(Y1 <= l && r <= Y2)return t[num][rt];
    int mid = l + r >> 1;
    ll ret = 0;
    if(Y1 <= mid)ret += requery(lson, l, mid, Y1, Y2, num);
    if(mid < Y2)ret += requery(rson, mid + 1, r, Y1, Y2, num);
    return ret;
}

ll query(int rt, int l, int r, int X1, int Y1, int X2, int Y2){
    if(X1 <= l && r <= X2)return requery(1, 1, n, Y1, Y2, rt);
    int mid = l + r >> 1;
    ll ret = 0;
    if(X1 <= mid)ret += query(lson, l, mid, X1, Y1, X2, Y2);
    if(mid < X2)ret += query(rson, mid + 1, r, X1, Y1, X2, Y2);
    return ret;
}


1.2 二维树状数组
// 单点更新+区间查询

const int maxn = 1e3 + 10;
int t[maxn][maxn], n;

void update(int x, int y){
    while(x <= n){
        int dy = y;
        while(dy <= n)t[x][dy] += 1, dy += lowbit(dy);
        x += lowbit(x);
    }
}

int getsum(int x, int y){
    int ret = 0;
    while(x){
        int dy = y;
        while(dy)ret += t[x][dy], dy -= lowbit(dy);
        x -= lowbit(x);
    }
    return ret;
}


1.3 树链剖分
树链剖分 ：把一棵树拆成若干个不相交的链，然后用数据结构去维护这些链
树链剖分操作：
1.对子树所有结点求和 2.对子树所有结点进行更新
3.对任意两点间的路径上所有点求和 4.对任意两点间的路径上所有点进行更新

struct node{
    int to, next;
}s[maxn];
int tree[maxn << 2], lazy[maxn << 2];
int head[maxn], tot, cnt, w[maxn], mod, n, m, r;
int son[maxn], fa[maxn], sz[maxn], d[maxn], top[maxn], id[maxn], wt[maxn];

//根据dfs序进行线段树区间求和, 区间修改(子树修改及求和)

void pushdown(int rt, int len){
    if(lazy[rt]){
        lazy[lson] += lazy[rt], lazy[rson] += lazy[rt];
        tree[lson] += lazy[rt] * ((len - (len >> 1)) % mod) % mod;
        tree[rson] += lazy[rt] * ((len >> 1) % mod) % mod;
        lazy[lson] %= mod, lazy[rson] %= mod;
        tree[lson] %= mod, tree[rson] %= mod;
        lazy[rt] = 0;
    }
}

void build(int l, int r, int rt){
    if(l == r)return void(tree[rt] = wt[l]);
    int mid = l + r >> 1;
    build(l, mid, lson), build(mid + 1, r, rson);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

void update(int l, int r, int L, int R, int rt, int y){
    if(L <= l && r <= R){
        lazy[rt] = (lazy[rt] + y) % mod;
        tree[rt] += y % mod * ((r - l + 1) % mod) % mod;
        return ;
    }
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1;
    if(L <= mid)update(l, mid, L, R, lson, y);
    if(mid < R)update(mid + 1, r, L, R, rson, y);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

int query(int l, int r, int L, int R, int rt){
    if(L <= l && r <= R)return tree[rt];
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1, ret = 0;
    if(L <= mid)ret = (ret + query(l, mid, L, R, lson)) % mod;
    if(mid < R)ret = (ret + query(mid + 1, r, L, R, rson)) % mod;
    return ret;
}

//树链剖分(两点间修改及求和)

void dfs1(int u, int pre){// 第一次遍历，找每个点的重儿子
    // 记录深度、子树大小、父亲结点
    d[u] = d[pre] + 1, sz[u] = 1, fa[u] = pre;
    // 记录重儿子子树大小
    int mson = -1;
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre)continue;
        dfs1(to, u);
        sz[u] += sz[to];
        if(sz[to] > mson)son[u] = to, mson = sz[to];// 记录每个结点重儿子位置及子树大小
    }
}

void dfs2(int u, int pre, int topx){//第二次遍历，生成dfs序，将树剖分为不相关的链
    id[u] = ++ cnt, wt[cnt] = w[u];
    top[u] = topx;
    // 记录dfs序、 每个点所在链的顶端结点
    if(!son[u])return ;
    dfs2(son[u], u, topx);
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre || to == son[u])continue;
        dfs2(to, u, to);// 轻儿子，存在一条从轻儿子开始的链，顶端结点为本身
    }
}

int qlink(int a, int b){// 两点间查询
    int ret = 0;
    while(top[a] != top[b]){// 当两点不在一条链上
        if(d[top[a]] < d[top[b]])swap(a, b);// 把a变为深度大的那一点, 再求链上的权值和
        ret = (ret + query(1, n, id[top[a]], id[a], 1)) % mod;// 对[a的顶端结点, a]求和
        a = fa[top[a]];// a变为a的顶端结点的父节点
    }
    if(d[a] < d[b])swap(a, b);// 属于同一条链, 直接求和
    ret = (ret + query(1, n, id[b], id[a], 1)) % mod;
    return ret;
}

void uplink(int a, int b, int y){// 两点间更新
    while(top[a] != top[b]){
        if(d[top[a]] < d[top[b]])swap(a, b);
        update(1, n, id[top[a]], id[a], 1, y);
        a = fa[top[a]];
    }
    if(d[a] < d[b])swap(a, b);
    update(1, n, id[b], id[a], 1, y);
}


1.4 树上启发式合并
树上启发式合并处理某些树上离线问题，复杂度O（nlogn）
模板例题：统计节点子树出现颜色种数或子树出现不同颜色权值等

// sz: 子树大小   big: 重儿子   col: 结点颜色    Node[i]: DFS 序为 i 的结点
// L[u]: 结点 u 的 DFS 序    R[u]: 结点 u 子树中结点的 DFS 序的最大值
// Node[i]: DFS 序为 i 的结点     ans: 存答案
// cnt[i]: 颜色为 i 的结点个数    totColor: 目前出现过的颜色个数
const int N = 2e5 + 5;
int n, sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;
vector<int> g[N];

void add(int u) {
    if (cnt[col[u]] == 0) ++totColor;
    cnt[col[u]]++;
}
void del(int u) {
    cnt[col[u]]--;
    if (cnt[col[u]] == 0) --totColor;
}

void dfs0(int u, int p) {
    L[u] = ++ totdfn;
    Node[totdfn] = u;
    sz[u] = 1;
    for (int v : g[u]){
        if (v != p) {
            dfs0(v, u);
            sz[u] += sz[v];
            if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
        }
    }
    R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
    // 计算轻儿子的答案
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            dfs1(v, u, false);
        }
    }
    // 计算重儿子答案并保留计算过程中的数据（用于继承）
    if (big[u]) {
        dfs1(big[u], u, true);
    }
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            // 子树结点的 DFS 序构成一段连续区间，可以直接遍历
            for (int i = L[v]; i <= R[v]; i++) {
                add(Node[i]);
            }
        }
    }
    add(u);
    ans[u] = totColor;
    if (keep == false) {
        for (int i = L[u]; i <= R[u]; i++) {
            del(Node[i]);
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs0(1, 0);
    dfs1(1, 0, false);
    for (int i = 1; i <= n; i++) printf("%d%c", ans[i], " \n"[i == n]);
}


1.5 普通平衡树Treap
Treap操作：
1.插入数值 x。
2.删除数值 x(若有多个相同的数，应只删除一个)。
3.查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4.查询排名为 x 的数值。
5.求数值 x 的前驱(前驱定义为小于 x 的最大的数)
6.求数值 x 的后继(后继定义为大于 x 的最小的数)
acwing 253

typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 2e6 + 10;

int n;
struct Node{
    int l, r;
    int key, val;
    int cnt, size;
}tr[maxn];

int root, idx;

void pushup(int p){
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key){
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &p){    // 右旋
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &p){    // 左旋
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build(){
    get_node(-inf), get_node(inf);
    root = 1, tr[1].r = 2;
    pushup(root);

    if (tr[1].val < tr[2].val) zag(root);
}


void insert(int &p, int key){
    if (!p) p = get_node(key);
    else if (tr[p].key == key) tr[p].cnt ++ ;
    else if (tr[p].key > key){
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else{
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &p, int key){
    if (!p) return;
    if (tr[p].key == key){
        if (tr[p].cnt > 1) tr[p].cnt -- ;
        else if (tr[p].l || tr[p].r){
            if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val){
                zig(p);
                remove(tr[p].r, key);
            }
            else{
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if (tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);
    pushup(p);
}

int get_rank_by_key(int p, int key){    // 通过数值找排名
    if (!p) return 0;   // 本题中不会发生此情况
    if (tr[p].key == key) return tr[tr[p].l].size + 1;
    if (tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int p, int rank){   // 通过排名找数值
    if (!p) return inf;     // 本题中不会发生此情况
    if (tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l, rank);
    if (tr[tr[p].l].size + tr[p].cnt >= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int getpre(int p, int key){   // 找到严格小于key的最大数
    if (!p) return -inf;
    if (tr[p].key >= key) return getpre(tr[p].l, key);
    return max(tr[p].key, getpre(tr[p].r, key));
}

int getnex(int p, int key){    // 找到严格大于key的最小数
    if (!p) return inf;
    if (tr[p].key <= key) return getnex(tr[p].r, key);
    return min(tr[p].key, getnex(tr[p].l, key));
}

int main(){
    build();
    scanf("%d", &n);
    while (n -- ){
        int opt, x;
        scanf("%d%d", &opt, &x);
        if (opt == 1) insert(root, x);
        else if (opt == 2) remove(root, x);
        else if (opt == 3) printf("%d\n", get_rank_by_key(root, x) - 1);
        else if (opt == 4) printf("%d\n", get_key_by_rank(root, x + 1));
        else if (opt == 5) printf("%d\n", getpre(root, x));
        else printf("%d\n", getnex(root, x));
    }
    return 0;
}


1.6 可持久化线段树(主席树)
可持久性线段树（主席树）
可持久化线段树模板：求静态区间[l,r]第k大，
求区间第k大，需离散化处理，然后不断更新得到不同版本的线段树，
然后将r版本的线段树减去l-1版本的线段树得到另一线段树，在此线段树上求区间第k大

const int maxn = 1e5 + 10;
struct  node{
    int l, r, v;
}t[maxn << 5];
int s[maxn], a[maxn], n, m, root[maxn], tot;

// 建树
int bulid(int l, int r){
    //新建结点
    int rt = ++ tot;
    t[rt].v = 0;

    if(l == r)return rt;
    int mid = l + r >> 1;
    // 左右儿子序号
    t[rt].l = bulid(l, mid), t[rt].r = bulid(mid + 1, r);
    
    return rt;
}

// 更新线段树版本，最后返回更新后的当前版本的根结点序号（单点更新）
int update(int node, int l, int r, int pos){
    // 线段树更新时，在当前需更新位置新建结点，初始时新建左右儿子不变，值加1
    int rt = ++ tot;
    t[rt] = t[node], t[rt].v ++;
    
    if(l == r)return rt;//更新结束

    int mid = l + r >> 1;
    //若更新位置在左边区间，则左儿子变化（否则右儿子变化）
    if(pos <= mid)t[rt].l = update(t[rt].l, l, mid, pos);
    else t[rt].r = update(t[rt].r, mid + 1, r, pos);

    return rt;
}

//查询区间[a + 1, b]第k大
int query(int a, int b, int l, int r, int k){
    if(l == r)return l;
    // 对当前区间[l, r]，求[l, l + r >> 1]内元素个数
    int sum = t[t[b].l].v - t[t[a].l].v, mid = l + r >> 1;
    //若k小于sum，则第k大在左边区间内，否则在右边区间[l + r >> 1 + 1, r]上找第k - sum大元素
    if(sum >= k)return query(t[a].l, t[b].l, l, mid, k);
    else return query(t[a].r, t[b].r, mid + 1, r, k - sum);
}   

void init(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++)scanf("%d", &s[i]), a[i] = s[i];
    //离散化
    sort(s + 1, s + n + 1);
    int q = unique(s + 1, s + n + 1) - s - 1;
    
    root[0] = bulid(1, q);
    
    for(int i = 1; i <= n; i ++){
        int pos = lower_bound(s + 1, s + q + 1, a[i]) - s;
        //在前一版本线段树上更新，得到当前版本的根结点序号
        root[i] = update(root[i - 1], 1, q, pos);
    }
   
    while(m --){
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        //区间[l,r]第k大元素在离散化数组下标
        int id = query(root[l - 1], root[r], 1, q, k);
        printf("%d\n", s[id]);
    }
}


1.7 Trie树

// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量
int son[N][26], cnt[N], idx;

// 插入一个字符串
void insert(char *str){
    int p = 0;
    for (int i = 0; str[i]; i ++ ){
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询单个字符串出现的次数
int query(char *str){
    int p = 0;
    for (int i = 0; str[i]; i ++ ){
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
