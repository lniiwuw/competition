3.1 求逆元

1.费马小定理,a的逆元为a的mod-2次方，条件：mod为质数，且mod与a互质

const int mod = 1e9 + 7;
ll qpow(ll a,ll b){
    ll ret = 1;
    while(b){
        if(b&1)//奇数
            ret = (ret * a) % mod;
        b >>= 1;
        a = (a * a) % mod;
    }
    return ret;
}

2.拓展欧几里得定理，条件：n与mod互质，但mod可以不为质数

void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
}

ll Inv(ll n) {
    ll x, y;
    exgcd(n, mod, x, y);
    x = (x + mod) % mod;
    return x;//n的逆元
}

3.线性递推求1~n逆元
由k*i+r=p(mod p)推出inv[i]=-(mod/i)*inv[mod%i]%mod;

void Inv(int n){
    int inv[100000];
    inv[1] = 1;
    for (int i = 2; i < mod; ++i)
    inv[i] = (mod - mod / i) * inv[mod % i] % mod;//保证为正数 
}

4.求阶乘逆元
inv[i+1]为(i+1)!的逆元，由inv[i+1]*(i+1)=inv[i]

void Inv(int n){
    int inv[10000];
    int k;
    inv[n+1] = k;//n!的逆元，可由费马小定理求得
    for (int i = n; i >= 1;i--)
        inv[i] = inv[i + 1] * (i + 1);
}
