1. 数据结构

1.1 二维线段树
//建树O(n^2) 查询O（logn ^ 2） 区间查询(x1,y1)×(x2,y2)矩形内元素和

const int maxn = 1e3 + 10;
#define lson rt << 1 
#define rson rt << 1 | 1

ll t[maxn << 2][maxn << 2];
int n;

void rebuild(int rt, int l, int r, int num){
    t[num][rt] = 0;
    if(l == r)return ;
    int mid = l + r >> 1;
    rebuild(lson, l, mid, num), rebuild(rson, mid + 1, r, num);
}

void build(int rt, int l, int r){
    rebuild(1, 1, n, rt);
    if(l == r)return;
    int mid = l + r >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
}

void reupdate(int rt, int l, int r, int y, int num, int d){
    if(l == r)return void(t[num][rt] += d);
    int mid = l + r >> 1;
    if(y <= mid)reupdate(lson, l, mid, y, num, d);
    else reupdate(rson, mid + 1, r, y, num, d);
    t[num][rt] = t[num][lson] + t[num][rson];
}

void update(int rt, int l, int r, int x, int y, int d){
    reupdate(1, 1, n, y, rt, d);
    if(l == r)return;
    int mid = l + r >> 1;
    if(x <= mid)update(lson, l, mid, x, y, d);
    else update(rson, mid + 1, r, x, y, d);
}

ll requery(int rt, int l, int r, int Y1, int Y2, int num){
    if(Y1 <= l && r <= Y2)return t[num][rt];
    int mid = l + r >> 1;
    ll ret = 0;
    if(Y1 <= mid)ret += requery(lson, l, mid, Y1, Y2, num);
    if(mid < Y2)ret += requery(rson, mid + 1, r, Y1, Y2, num);
    return ret;
}

ll query(int rt, int l, int r, int X1, int Y1, int X2, int Y2){
    if(X1 <= l && r <= X2)return requery(1, 1, n, Y1, Y2, rt);
    int mid = l + r >> 1;
    ll ret = 0;
    if(X1 <= mid)ret += query(lson, l, mid, X1, Y1, X2, Y2);
    if(mid < X2)ret += query(rson, mid + 1, r, X1, Y1, X2, Y2);
    return ret;
}


1.2 二维树状数组
// 单点更新+区间查询

const int maxn = 1e3 + 10;
int t[maxn][maxn], n;

void update(int x, int y){
    while(x <= n){
        int dy = y;
        while(dy <= n)t[x][dy] += 1, dy += lowbit(dy);
        x += lowbit(x);
    }
}

int getsum(int x, int y){
    int ret = 0;
    while(x){
        int dy = y;
        while(dy)ret += t[x][dy], dy -= lowbit(dy);
        x -= lowbit(x);
    }
    return ret;
}


1.3 树链剖分
树链剖分 ：把一棵树拆成若干个不相交的链，然后用数据结构去维护这些链
树链剖分操作：
1.对子树所有结点求和 2.对子树所有结点进行更新
3.对任意两点间的路径上所有点求和 4.对任意两点间的路径上所有点进行更新

struct node{
    int to, next;
}s[maxn];
int tree[maxn << 2], lazy[maxn << 2];
int head[maxn], tot, cnt, w[maxn], mod, n, m, r;
int son[maxn], fa[maxn], sz[maxn], d[maxn], top[maxn], id[maxn], wt[maxn];

//根据dfs序进行线段树区间求和, 区间修改(子树修改及求和)

void pushdown(int rt, int len){
    if(lazy[rt]){
        lazy[lson] += lazy[rt], lazy[rson] += lazy[rt];
        tree[lson] += lazy[rt] * ((len - (len >> 1)) % mod) % mod;
        tree[rson] += lazy[rt] * ((len >> 1) % mod) % mod;
        lazy[lson] %= mod, lazy[rson] %= mod;
        tree[lson] %= mod, tree[rson] %= mod;
        lazy[rt] = 0;
    }
}

void build(int l, int r, int rt){
    if(l == r)return void(tree[rt] = wt[l]);
    int mid = l + r >> 1;
    build(l, mid, lson), build(mid + 1, r, rson);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

void update(int l, int r, int L, int R, int rt, int y){
    if(L <= l && r <= R){
        lazy[rt] = (lazy[rt] + y) % mod;
        tree[rt] += y % mod * ((r - l + 1) % mod) % mod;
        return ;
    }
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1;
    if(L <= mid)update(l, mid, L, R, lson, y);
    if(mid < R)update(mid + 1, r, L, R, rson, y);
    tree[rt] = (tree[lson] + tree[rson]) % mod;
}

int query(int l, int r, int L, int R, int rt){
    if(L <= l && r <= R)return tree[rt];
    pushdown(rt, r - l + 1);
    int mid = l + r >> 1, ret = 0;
    if(L <= mid)ret = (ret + query(l, mid, L, R, lson)) % mod;
    if(mid < R)ret = (ret + query(mid + 1, r, L, R, rson)) % mod;
    return ret;
}

//树链剖分(两点间修改及求和)

void dfs1(int u, int pre){// 第一次遍历，找每个点的重儿子
    // 记录深度、子树大小、父亲结点
    d[u] = d[pre] + 1, sz[u] = 1, fa[u] = pre;
    // 记录重儿子子树大小
    int mson = -1;
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre)continue;
        dfs1(to, u);
        sz[u] += sz[to];
        if(sz[to] > mson)son[u] = to, mson = sz[to];// 记录每个结点重儿子位置及子树大小
    }
}

void dfs2(int u, int pre, int topx){//第二次遍历，生成dfs序，将树剖分为不相关的链
    id[u] = ++ cnt, wt[cnt] = w[u];
    top[u] = topx;
    // 记录dfs序、 每个点所在链的顶端结点
    if(!son[u])return ;
    dfs2(son[u], u, topx);
    for(int i = head[u]; ~i; i = s[i].next){
        int to = s[i].to;
        if(to == pre || to == son[u])continue;
        dfs2(to, u, to);// 轻儿子，存在一条从轻儿子开始的链，顶端结点为本身
    }
}

int qlink(int a, int b){// 两点间查询
    int ret = 0;
    while(top[a] != top[b]){// 当两点不在一条链上
        if(d[top[a]] < d[top[b]])swap(a, b);// 把a变为深度大的那一点, 再求链上的权值和
        ret = (ret + query(1, n, id[top[a]], id[a], 1)) % mod;// 对[a的顶端结点, a]求和
        a = fa[top[a]];// a变为a的顶端结点的父节点
    }
    if(d[a] < d[b])swap(a, b);// 属于同一条链, 直接求和
    ret = (ret + query(1, n, id[b], id[a], 1)) % mod;
    return ret;
}

void uplink(int a, int b, int y){// 两点间更新
    while(top[a] != top[b]){
        if(d[top[a]] < d[top[b]])swap(a, b);
        update(1, n, id[top[a]], id[a], 1, y);
        a = fa[top[a]];
    }
    if(d[a] < d[b])swap(a, b);
    update(1, n, id[b], id[a], 1, y);
}


1.4 树上启发式合并
树上启发式合并处理某些树上离线问题，复杂度O（nlogn）
模板例题：统计节点子树出现颜色种数或子树出现不同颜色权值等

// sz: 子树大小   big: 重儿子   col: 结点颜色    Node[i]: DFS 序为 i 的结点
// L[u]: 结点 u 的 DFS 序    R[u]: 结点 u 子树中结点的 DFS 序的最大值
// Node[i]: DFS 序为 i 的结点     ans: 存答案
// cnt[i]: 颜色为 i 的结点个数    totColor: 目前出现过的颜色个数
const int N = 2e5 + 5;
int n, sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;
vector<int> g[N];

void add(int u) {
    if (cnt[col[u]] == 0) ++totColor;
    cnt[col[u]]++;
}
void del(int u) {
    cnt[col[u]]--;
    if (cnt[col[u]] == 0) --totColor;
}

void dfs0(int u, int p) {
    L[u] = ++ totdfn;
    Node[totdfn] = u;
    sz[u] = 1;
    for (int v : g[u]){
        if (v != p) {
            dfs0(v, u);
            sz[u] += sz[v];
            if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
        }
    }
    R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
    // 计算轻儿子的答案
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            dfs1(v, u, false);
        }
    }
    // 计算重儿子答案并保留计算过程中的数据（用于继承）
    if (big[u]) {
        dfs1(big[u], u, true);
    }
    for (int v : g[u]){
        if (v != p && v != big[u]) {
            // 子树结点的 DFS 序构成一段连续区间，可以直接遍历
            for (int i = L[v]; i <= R[v]; i++) {
                add(Node[i]);
            }
        }
    }
    add(u);
    ans[u] = totColor;
    if (keep == false) {
        for (int i = L[u]; i <= R[u]; i++) {
            del(Node[i]);
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs0(1, 0);
    dfs1(1, 0, false);
    for (int i = 1; i <= n; i++) printf("%d%c", ans[i], " \n"[i == n]);
}


1.5 普通平衡树Treap
Treap操作：
1.插入数值 x。
2.删除数值 x(若有多个相同的数，应只删除一个)。
3.查询数值 x 的排名(若有多个相同的数，应输出最小的排名)。
4.查询排名为 x 的数值。
5.求数值 x 的前驱(前驱定义为小于 x 的最大的数)
6.求数值 x 的后继(后继定义为大于 x 的最小的数)
acwing 253

typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 2e6 + 10;

int n;
struct Node{
    int l, r;
    int key, val;
    int cnt, size;
}tr[maxn];

int root, idx;

void pushup(int p){
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + tr[p].cnt;
}

int get_node(int key){
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void zig(int &p){    // 右旋
    int q = tr[p].l;
    tr[p].l = tr[q].r, tr[q].r = p, p = q;
    pushup(tr[p].r), pushup(p);
}

void zag(int &p){    // 左旋
    int q = tr[p].r;
    tr[p].r = tr[q].l, tr[q].l = p, p = q;
    pushup(tr[p].l), pushup(p);
}

void build(){
    get_node(-inf), get_node(inf);
    root = 1, tr[1].r = 2;
    pushup(root);

    if (tr[1].val < tr[2].val) zag(root);
}


void insert(int &p, int key){
    if (!p) p = get_node(key);
    else if (tr[p].key == key) tr[p].cnt ++ ;
    else if (tr[p].key > key){
        insert(tr[p].l, key);
        if (tr[tr[p].l].val > tr[p].val) zig(p);
    }
    else{
        insert(tr[p].r, key);
        if (tr[tr[p].r].val > tr[p].val) zag(p);
    }
    pushup(p);
}

void remove(int &p, int key){
    if (!p) return;
    if (tr[p].key == key){
        if (tr[p].cnt > 1) tr[p].cnt -- ;
        else if (tr[p].l || tr[p].r){
            if (!tr[p].r || tr[tr[p].l].val > tr[tr[p].r].val){
                zig(p);
                remove(tr[p].r, key);
            }
            else{
                zag(p);
                remove(tr[p].l, key);
            }
        }
        else p = 0;
    }
    else if (tr[p].key > key) remove(tr[p].l, key);
    else remove(tr[p].r, key);
    pushup(p);
}

int get_rank_by_key(int p, int key){    // 通过数值找排名
    if (!p) return 0;   // 本题中不会发生此情况
    if (tr[p].key == key) return tr[tr[p].l].size + 1;
    if (tr[p].key > key) return get_rank_by_key(tr[p].l, key);
    return tr[tr[p].l].size + tr[p].cnt + get_rank_by_key(tr[p].r, key);
}

int get_key_by_rank(int p, int rank){   // 通过排名找数值
    if (!p) return inf;     // 本题中不会发生此情况
    if (tr[tr[p].l].size >= rank) return get_key_by_rank(tr[p].l, rank);
    if (tr[tr[p].l].size + tr[p].cnt >= rank) return tr[p].key;
    return get_key_by_rank(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);
}

int getpre(int p, int key){   // 找到严格小于key的最大数
    if (!p) return -inf;
    if (tr[p].key >= key) return getpre(tr[p].l, key);
    return max(tr[p].key, getpre(tr[p].r, key));
}

int getnex(int p, int key){    // 找到严格大于key的最小数
    if (!p) return inf;
    if (tr[p].key <= key) return getnex(tr[p].r, key);
    return min(tr[p].key, getnex(tr[p].l, key));
}

int main(){
    build();
    scanf("%d", &n);
    while (n -- ){
        int opt, x;
        scanf("%d%d", &opt, &x);
        if (opt == 1) insert(root, x);
        else if (opt == 2) remove(root, x);
        else if (opt == 3) printf("%d\n", get_rank_by_key(root, x) - 1);
        else if (opt == 4) printf("%d\n", get_key_by_rank(root, x + 1));
        else if (opt == 5) printf("%d\n", getpre(root, x));
        else printf("%d\n", getnex(root, x));
    }
    return 0;
}


1.6 可持久化线段树(主席树)
可持久性线段树（主席树）
可持久化线段树模板：求静态区间[l,r]第k大，
求区间第k大，需离散化处理，然后不断更新得到不同版本的线段树，
然后将r版本的线段树减去l-1版本的线段树得到另一线段树，在此线段树上求区间第k大

const int maxn = 1e5 + 10;
struct  node{
    int l, r, v;
}t[maxn << 5];
int s[maxn], a[maxn], n, m, root[maxn], tot;

// 建树
int bulid(int l, int r){
    //新建结点
    int rt = ++ tot;
    t[rt].v = 0;

    if(l == r)return rt;
    int mid = l + r >> 1;
    // 左右儿子序号
    t[rt].l = bulid(l, mid), t[rt].r = bulid(mid + 1, r);
    
    return rt;
}

// 更新线段树版本，最后返回更新后的当前版本的根结点序号（单点更新）
int update(int node, int l, int r, int pos){
    // 线段树更新时，在当前需更新位置新建结点，初始时新建左右儿子不变，值加1
    int rt = ++ tot;
    t[rt] = t[node], t[rt].v ++;
    
    if(l == r)return rt;//更新结束

    int mid = l + r >> 1;
    //若更新位置在左边区间，则左儿子变化（否则右儿子变化）
    if(pos <= mid)t[rt].l = update(t[rt].l, l, mid, pos);
    else t[rt].r = update(t[rt].r, mid + 1, r, pos);

    return rt;
}

//查询区间[a + 1, b]第k大
int query(int a, int b, int l, int r, int k){
    if(l == r)return l;
    // 对当前区间[l, r]，求[l, l + r >> 1]内元素个数
    int sum = t[t[b].l].v - t[t[a].l].v, mid = l + r >> 1;
    //若k小于sum，则第k大在左边区间内，否则在右边区间[l + r >> 1 + 1, r]上找第k - sum大元素
    if(sum >= k)return query(t[a].l, t[b].l, l, mid, k);
    else return query(t[a].r, t[b].r, mid + 1, r, k - sum);
}   

void init(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i ++)scanf("%d", &s[i]), a[i] = s[i];
    //离散化
    sort(s + 1, s + n + 1);
    int q = unique(s + 1, s + n + 1) - s - 1;
    
    root[0] = bulid(1, q);
    
    for(int i = 1; i <= n; i ++){
        int pos = lower_bound(s + 1, s + q + 1, a[i]) - s;
        //在前一版本线段树上更新，得到当前版本的根结点序号
        root[i] = update(root[i - 1], 1, q, pos);
    }
   
    while(m --){
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        //区间[l,r]第k大元素在离散化数组下标
        int id = query(root[l - 1], root[r], 1, q, k);
        printf("%d\n", s[id]);
    }
}


1.7 Trie树

// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量
int son[N][26], cnt[N], idx;

// 插入一个字符串
void insert(char *str){
    int p = 0;
    for (int i = 0; str[i]; i ++ ){
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询单个字符串出现的次数
int query(char *str){
    int p = 0;
    for (int i = 0; str[i]; i ++ ){
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}



2.字符串处理

2.1 字符串哈希
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ull;
// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
ull h[maxn], p[maxn];
// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ ){
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ull get(int l, int r){
    return h[r] - h[l - 1] * p[r - l + 1];
}

2.2 KMP

//求给定子串p的next数组，记录前后缀相等的长度
void getnext(){
    nex[0] = nex[1] = 0;
    int n = strlen(p + 1);
    for(int i = 2; i <= n; i ++){
        int j = nex[i - 1];
        while(j && p[i] != p[j + 1])j = nex[j];
        nex[i] = (p[i] == p[j + 1]) ? j + 1 : 0;
    }
}

//查询在字符串p在s中的出现次数ans
void kmp(){
    int j = nex[1], ans = 0;
    int m = strlen(s + 1);
    for(int i = 1; i <= m; i ++){
        while(j && s[i] != p[j + 1])j = nex[j];
        if(s[i] == p[j + 1])j ++;
        if(j == n)ans ++;
    }
}


2.3 AC自动机
求多个模式串分别在文本串中的出现次数

const int maxn = 2e6 + 10;

int tree[maxn][26], fail[maxn], sum[maxn];
int in[maxn], mp[maxn];
int n, len, tot;
char s[maxn], s1[2 * maxn];

// 插入
void insert(int k){
    int rt = 0;
    for(int i = 1; i <= len; i ++){
        int a = s1[i] - 'a';
        if(!tree[rt][a])tree[rt][a] = ++ tot;
        rt = tree[rt][a];
    }
    mp[k] = rt;
}

// 生成fail指针
void build(){
    queue<int> q;
    for(int i = 0; i < 26; i ++){
        if(tree[0][i])q.push(tree[0][i]);
    }
    while(q.size()){
        int a = q.front(); q.pop();
        for(int i = 0; i < 26; i ++){
            int b = tree[a][i];
            if(!b){tree[a][i] = tree[fail[a]][i]; continue;}
            fail[b] = tree[fail[a]][i];
            q.push(b);
            in[fail[b]] ++;//拓扑排序入度
        }
    }
}

// 拓扑排序优化
void topo(){
    queue<int> q;
    for(int i = 1; i <= tot; i ++){
        if(in[i] == 0)q.push(i);
    }
    while(q.size()){
        int a = q.front(); q.pop();
        int b = fail[a];
        in[b] --;
        sum[b] += sum[a];
        if(in[b] == 0)q.push(b);
    }
}

int main(){
    int t, q, x, y;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++){
        scanf("%s", s1 + 1);
        len = strlen(s1 + 1);
        insert(i);
    }
    scanf("%s", s + 1);
    build();
    int rt = 0;
    len = strlen(s + 1);
    for(int i = 1; i <= len; i ++){
        int a = s[i] - 'a';
        rt = tree[rt][a];
        sum[rt] ++;
    }
    topo();
    for(int i = 1; i <= n; i ++)printf("%d\n", sum[mp[i]]);
    return 0;
}


3. 数学

3.1 求逆元

1.费马小定理,a的逆元为a的mod-2次方，条件：mod为质数，且mod与a互质

const int mod = 1e9 + 7;
ll qpow(ll a,ll b){
    ll ret = 1;
    while(b){
        if(b&1)//奇数
            ret = (ret * a) % mod;
        b >>= 1;
        a = (a * a) % mod;
    }
    return ret;
}

2.拓展欧几里得定理，条件：n与mod互质，但mod可以不为质数

void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    ll t = x;
    x = y;
    y = t - a / b * y;
}

ll Inv(ll n) {
    ll x, y;
    exgcd(n, mod, x, y);
    x = (x + mod) % mod;
    return x;//n的逆元
}

3.线性递推求1~n逆元
由k*i+r=p(mod p)推出inv[i]=-(mod/i)*inv[mod%i]%mod;

void Inv(int n){
    int inv[100000];
    inv[1] = 1;
    for (int i = 2; i < mod; ++i)
    inv[i] = (mod - mod / i) * inv[mod % i] % mod;//保证为正数 
}

4.求阶乘逆元
inv[i+1]为(i+1)!的逆元，由inv[i+1]*(i+1)=inv[i]

void Inv(int n){
    int inv[10000];
    int k;
    inv[n+1] = k;//n!的逆元，可由费马小定理求得
    for (int i = n; i >= 1;i--)
        inv[i] = inv[i + 1] * (i + 1);
}


3.2 线性基
线性基三大性质：
线性基异或形成的集合与原数集异或形成的集合相同
1.原序列里面的任意一个数都可以由线性基里面的一些数异或得到
2.线性基里面的任意一些数异或起来都不能得到0
3.线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的

ll s[maxn], n, p[maxn];

//求集合s的线性基，数组p存放集合s的线性基
void solvex(){
    for(int i = 1; i <= n; i ++){
        ll a = s[i];
        for(int j = 60; j >= 0; j --){
            if(a & (1ll << j)){
                if(!p[j]){p[j] = a; break;}
                else a ^= p[j];
            }
        }
    }
}

// 求集合s异或最大值
ll solvemaxx(){
    ll ans = 0;
    for(int i = 60; i >= 0; i --){
        if((ans ^ p[i]) > ans) ans = ans ^ p[i];
    }
    return ans;
}


3.3 欧拉函数

n的欧拉函数值
int oula(int n){
    int ans = n;
    for(int i = 2; 1ll * i * i <= n; i ++){
      if(n % i == 0){
      ans -= ans/i;
      while(n % i == 0)n /= i;
      }
    }
    if(n != 1)ans -= ans/n;
	return ans;
}


线性筛求欧拉函数 O(n)
void getoula(){
    memset(vis, 1, sizeof vis);
    vis[1] = 0, sum[1] = 1;
    for(int i = 2; i <= maxn; i ++){
        if(vis[i])p[++ tot] = i, sum[i] = i - 1;//存欧拉函数值
        for(int j = 1; j <= tot && i * p[j] <= maxn; j ++){
            vis[i * p[j]] = 0;
            if(i % p[j] == 0){
                sum[i * p[j]] = p[j] * sum[i];
                break;
            }
            sum[i * p[j]] = (p[j] - 1) * sum[i];
        }
    }
}


3.5 拓展欧几里得定理
求一组x, y 使得 ax + by = gcd(a, b)

void exgcd(int a, int b, int &x, int &y){
    if(b == 0){
        x = 1, y = 0;
        return ;
    }
    exgcd(b, a % b, x, y);
    int  t = x;
    x = y;
    y = t - a / b * y;
}


3.6  Pollard Rho算法+Miller-Rabin素数测试

Miller-Rabin素数测试：
快速判断一个1e18范围内的数是否为素数，对其进行Miller-Rabin素数测试;
可以大概率判断其是否为素数，出错的概率为1/4的k次方，k为测试次数。故当测试次数越多，其出错概率越小。
Pollard Rho算法：大数分解

寻找n最大的质因子(n<1e18)：

ll n, m, ans;

ll gcd(ll a, ll b){return b == 0 ? a : gcd(b, a % b);}

ll qmul(ll a, ll b, ll p){//快速乘
    ll z = (long double)a / p * b;
    ll ret = (ull)a * b - (ull)z * p;
    return (ret + p) % p;
}

ll qpow(ll a, ll b, ll p){//快速幂
    ll ret = 1;
    while(b){
        if(b & 1)ret = qmul(ret , a , p);
        b >>= 1;
        a = qmul(a, a, p);
    }
    return ret;
}

bool Miller_rabin(ll n){// Miller _ Rabin判断素数
    if(n == 2)return true;
    if(n < 2 || !(n & 1))return false;//特判
    ll m = n - 1, k = 0;
    while(!(m & 1))m >>= 1, k ++;// 求得2的幂次数
    for(int i = 1; i <= 6; i ++){// 测试次数
        ll a = rand() % (n - 1) + 1;// 随机生成a
        ll x = qpow(a, m, n), y;
        for(int j = 1; j <= k; j ++){
            y = qmul(x, x, n);
            if(y == 1 && x != 1 && x != n - 1)return false;
            // a ^ 2 = 1(mod p), p为质数，若a不为 1或者 n - 1， 则不符合二次探测定理
            x = y;
        }
        if(y != 1)return false;// 费马小定理的逆命题判断
    }
    return true;
}

ll Pollard_Rho(ll n){// 二次优化，减少了gcd的计算次数
    ll z, x, y, g, c;
    while(1){// 一定会找到一个因子
        int i = 0, j = 1;
        c = rand() % (n - 1) + 1;
        y = x = rand() % (n - 1) + 1;// 随机初始化
        z = 1;// 存 abs(x - y)的乘积
        while(++ i){
            x = (qmul(x, x, n) + c) % n;// x ^ 2 + c
            z = qmul(z, abs(x - y), n);
            if(!z || x == y)break; // z = 0时重新测试， x == y时即为跑完了环，也重新测试
            if(i == j || i % 127 == 0){// 当i == j 或者 i % 127 = 0 时，判断gcd
                g = gcd(n, z);
                if(g > 1)return g;// 找到了一个因子
                if(i == j)j <<= 1, y = x; // 倍增维护答案准确性
            }
        } 
    }
}

void pr(ll n){
    if(n <= ans)return; // 剪枝
    if(Miller_rabin(n)){ans = n; return ;}
    ll a = Pollard_Rho(n);
    while(n % a == 0)n /= a;
    pr(a), pr(n); // 继续分解
}


3.7 卡特兰数

给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：
Cat(n) = C(2n, n) / (n + 1)


3.8 勒让德定理

求阶乘质数因子的幂次数
int cal(int n,int p){
    if(n==0)//n为0时退出
        return 0;
    return n / p + cal(n / p, p);
}


3.9 数论分块

一维数论分块
int init(){
  int ans = 0;
    for(int l = 1, r; l <= n; l = r + 1){
        r = n/(n/l);
        ans += (n/l) * (r - l + 1); 
    }
    return ans;
}

二维数论分块
int init(){
    int ans = 0;
    for(int l = 1, r; l <= min(n, m); l = r + 1){
        r = min(n/(n/l), m/(m/l));
        ans += (n/l) * (m/l) * (r - l + 1); 
    }
    return ans;
}


4. 图论

4.1 spfa算法

求最短路
时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数
int n; // 总点数
int h[N], w[N], e[N], ne[N], idx;  // 邻接表存储所有边
int dist[N];   // 存储每个点到1号点的最短距离
bool st[N];    // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                // 如果队列中已存在j，则不需要将j重复插入
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

spfa判负环
int n;  // 总点数
int h[N], w[N], e[N], ne[N], idx;  // 邻接表存储所有边
int dist[N], cnt[N];  // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N]; // 存储每个点是否在队列中
// 如果存在负环，则返回true，否则返回false。
bool spfa(){
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    queue<int> q;
    for (int i = 1; i <= n; i ++ ){
        q.push(i);
        st[i] = true;
    }
    while (q.size()){
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (cnt[j] >= n) return true;      
                if (!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}


4.2 dinic算法（最大流）

时间复杂度O(n^2 * m)
#define ll long long 
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int maxn = 1e5 + 10;

struct node{
    int to, next, w;
}e[maxn];
int head[maxn], tot = -1;
int n, m, dep[maxn], s, t, q[maxn];

void add(int u, int v, int w){
    e[++ tot].to = v;
    e[tot].next = head[u];
    e[tot].w = w;
    head[u] = tot;
}

bool bfs(){
    memset(dep, 0, (n + 1) * sizeof(int));
    int hh = 0, tt = -1;
    q[++ tt] = s, dep[s] = 1;
    while(hh <= tt){
        int u = q[hh ++];
        for(int i = head[u]; ~i; i = e[i].next){
            int to = e[i].to;
            if(e[i].w && !dep[to])dep[to] = dep[u] + 1, q[++ tt] = to;
        }
    }
    return dep[t];
}

ll dfs(int u, ll in){
    if(u == t)return in;
    ll out = 0;
    for(int i = head[u]; ~i; i = e[i].next){
        int to = e[i].to;
        if(e[i].w && dep[to] == dep[u] + 1){
            int ret = dfs(to, min(in, 1ll * e[i].w));
            e[i].w -= ret, e[i ^ 1].w += ret;
            in -= ret, out += ret;
        }
    }
    if(out == 0)dep[u] = 0;
    return out;
}

int main(){
    memset(head, -1, sizeof head);
    scanf("%d%d%d%d", &n, &m, &s, &t);
    // 源点到汇点的最大流
    int a, b, c;
    while(m --){
        // 存在a -> b的边
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, 0);
    }
    ll ans = 0;
    while(bfs())ans += dfs(s, 1e18);
    printf("%lld\n", ans);
    return 0;
}


4.3 匈牙利算法
求二分图最大匹配

int n1, n2;  // n1表示第一个集合中的点数，n2表示第二个集合中的点数
// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int h[N], e[M], ne[M], idx; 
int match[N];  // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];    // 表示第二个集合中的每个点是否已经被遍历过
bool find(int x){
    for (int i = h[x]; i != -1; i = ne[i]){
        int j = e[i];
        if (!st[j]){
            st[j] = true;
            if (match[j] == 0 || find(match[j])){
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ ){
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}


4.4 染色法判断二分图

const int maxn = 1e5 + 10;
struct node{
    int to, next;
}s[maxn];
int n, m, tot, head[maxn];
int c[maxn];

void add(int u, int v){
    s[++ tot].to = v;
    s[tot].next = head[u];
    head[u] = tot;
}

bool dfs(int a, int b){
    c[a] = b;
    for(int i = head[a]; ~i; i = s[i].next){
        int to = s[i].to;
        if(c[to] == b)return false;
        if(c[to] == 0 && !dfs(to, -b))return false;
    }
    return true;
}

bool init(){
    memset(c, 0, sizeof c);
    memset(head, -1, sizeof head);
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i ++){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }    
    int flag = dfs(1, 1);
    if(n & 1)flag = false;
    return flag;//true为真
}


5.其他

5.1 高精度算法

高精度算法，数组存储：从低位-->高位
高精度加法，满足C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B){
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ ){
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

高精度减法，满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B){
    vector<int> c;
    
    for(int i = 0, t = 0; i < A.size(); i ++){
        t += A[i];
        if(i < B.size())t -= B[i];
        c.push_back((t + 10) % 10);
        if(t < 0)t = -1;
        else t = 0;
    }
    
    while(c.back() == 0 && c.size() > 1)c.pop_back();
    return c;
}

高精度乘法，高精度×低精度，// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b){
    vector<int> C;

    for (int i = 0, t = 0; i < A.size() || t; i ++ ){
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

高精度除法，高精度÷低精度，
A >= 0, b > 0, A除b余r
vector<int> div(vector<int> &A, int b, int &r){
    vector<int> C;  r = 0;
    
    for (int i = A.size() - 1; i >= 0; i -- ){
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}


5.2 差分矩阵

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


5.3 排序

// 快速排序 O(n logn)
void quick_sort(int s[], int l, int r){
    if(l >= r)return ;
    
    int i = l - 1, j= r + 1, t = s[l + r >> 1];// 以区间中间的数为基准
    while(i < j){
        while(s[++ i] < t);
        while(s[-- j] > t);
        if(i < j)swap(s[i], s[j]);
    }
    
    quick_sort(s, l, j), quick_sort(s, j + 1, r);
}

// 归并排序 O(n logn)
void merge_sort(int s[], int l, int r){
    if(l >= r)return ;
    
    int mid = l + r >> 1;
    merge_sort(s, l, mid), merge_sort(s, mid + 1, r);
    
    int i = l,j = mid + 1, k = 0;
    while(i <= mid && j <= r){
        if(s[i] < s[j])p[++ k] =  s[i ++];
        else p[++ k] = s[j ++];
    }
    while(i <= mid )p[++ k] = s[i ++];
    while(j <= r)p[++ k] = s[j ++];
    
    for(i = l,j = 1;i <= r; i ++, j ++)s[i] = p[j];
}


6.动态规划
6.1 背包

01背包：每件物品最多取一次使价值最大
n: 物品个数 v：背包容积
const int maxn = 1e4 + 10;
int dp[maxn], s[maxn][2], n, v;

int init(){
    cin >> n >> v;
    // 每件物品的容积和价值
    for(int i = 1; i <= n; i ++)cin >> s[i][0] >> s[i][1];
    /*for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= v; j ++){
            dp[i][j] = dp[i - 1][j];
            if(j >= s[i][0])dp[i][j] = max(dp[i][j], dp[i - 1][j - s[i][0]] + s[i][1]);
        }
    }
    cout << dp[n][v] << endl;
    */
    for(int i = 1; i <= n; i ++){
        for(int j = v; j >= s[i][0]; j --){
            dp[j] = max(dp[j], dp[j - s[i][0]] + s[i][1]);
        }
    }
    return dp[v];
}

完全背包：每件物品取任意多次使价值最大
n: 物品个数 v：背包容积
const int maxn = 1e4 + 10;
int dp[maxn], s[maxn][2], n, v;

int init(){
    cin >> n >> v;
    for(int i = 1; i <= n; i ++)cin >> s[i][0] >> s[i][1];
    /*for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= v; j ++){
            dp[i][j] = dp[i - 1][j];
            if(j >= s[i][0])dp[i][j] = max(dp[i][j - s[i][0]] + s[i][1], dp[i][j]); 
        }
    }*/
    for(int i = 1; i <= n; i ++){
        for(int j = s[i][0]; j <= v; j ++){
            dp[j] = max(dp[j], dp[j - s[i][0]] + s[i][1]);
        }
    }
    return dp[v];
}

多重背包：每件物品最多取c次，使总价值最大

二进制优化：
const int maxn = 1e4 + 10;
int dp[maxn], s[maxn][2];

int main(){
    int n, v;
    cin >> n >> v;
    for(int i = 1; i <= n; i ++){
        int a, b, c, d = 1, t = 0;
        // 物品最多取c次
        cin >> a >> b >> c;
        while(d <= c){
            s[++ t][0] = d * a, s[t][1] = d * b;
            c -= d;
            d *= 2;
        }
        if(c)s[++ t][0] = c * a, s[t][1] = c * b;
        for(int j = 1; j <= t; j ++){
            for(int k = v; k >= s[j][0]; k --){
                dp[k] = max(dp[k], dp[k - s[j][0]] + s[j][1]);
            }
        }
    }
    return dp[v];
}

优先队列优化：
O(NV)
const int maxn = 2e4 + 10;
int dp[maxn], pre[maxn], q[maxn];

// pre[q[hh]] - (q[hh] - j)/v1 * w1 + (k - j)/v1 * w1) = pre[q[hh]] + (k - q[hh])/v1 *w1

int init(){
    int n, v;
    cin >> n >> v;
    for(int i = 1; i <= n; i ++){
        int v1, w1, s1;
        cin >> v1 >> w1 >> s1;
        
        for(int j = 0; j < v1; j ++){
            int hh = 0, tt = -1;
            memcpy(pre, dp, sizeof dp);
            
            for(int k = j; k <= v; k += v1){
                
                while(hh <= tt && k - q[hh] > s1 * v1)hh ++;
                while(hh <= tt && pre[q[tt]] - (q[tt] - j)/v1 * w1 <= pre[k] - (k - j)/v1 * w1)tt --;
                if(hh <= tt)dp[k] = max(dp[k], pre[q[hh]] + (k - q[hh])/v1 * w1);
                
                q[++ tt] = k;
            }
        }
    }
    return dp[v];
}

二维费用背包：
每件物品有对应体积和重量，最多使用一次，使总价值最大
v：背包容积 w：背包承受重量
n：物品件数 
v1：物品对应体积 m1：对应重量 w1：对应价值
typedef long long ll;
const int maxn = 1e3 + 10;

ll read(){
    ll q = 0, w = 1;char ch = ' ';
    while(ch != '-' && (ch < '0' || ch > '9'))ch = getchar();
    if(ch == '-')w = -1, ch = getchar();
    while(ch >= '0' && ch <= '9')q = q * 10 + (ll)(ch - '0'),ch = getchar();
    return q * w;
}

int dp[maxn][maxn];
int n, v, m;

int init(){
    n = read(), v = read(), m = read(); 
    int v1, m1, w1;
    for(int i = 1; i <= n; i ++){
        v1 = read(), m1 = read(), w1 = read();
        for(int j = v; j >= v1; j --){
            for(int k = m; k >= m1; k --){
                dp[j][k] = max(dp[j][k], dp[j - v1][k - m1] + w1);
            }
        }
    }
    return dp[v][m];
}

分组背包：
有n组物品，同一组内只能选一个，使总价值最大
v：背包容积 n：物品组数 
const int N = 110;
int dp[N][N], s[N], v1[N][N], w[N][N];

int init(){
    int n, v;
    cin >> n >> v;
    for(int i = 1; i <= n; i ++){
        cin >> s[i];
        for(int j = 1; j <= s[i]; j ++)cin >> v1[i][j] >> w[i][j];
    }
    for(int i = 1; i <= n; i ++){
        for(int j = 0; j <= v; j ++){
            dp[i][j] = dp[i - 1][j];// 此层循环必须在外, 保证每组中最多放一个
            for(int k = 1; k <= s[i]; k ++){
                if(j >= v1[i][k])dp[i][j] = max(dp[i][j], dp[i - 1][j - v1[i][k]] + w[i][k]);
            }
        }
    }
    return dp[n][m];
}

01背包求方案数：

const int mod = 1e9 + 7;
const int maxn = 1e3 + 10;
int cnt[maxn], s[maxn][2], f[maxn];

int init(){
    int n, v;
    cin >> n >> v;
    for(int i = 1; i <= n; i ++)cin >> s[i][0] >> s[i][1];
    for(int i = 0; i <= v; i ++)cnt[i] = 1;
    for(int i = 1; i <= n; i ++){
        for(int j = v; j >= s[i][0]; j --){
            int v1 = f[j - s[i][0]] + s[i][1];
            if(v1 > f[j])f[j] = v1, cnt[j] = cnt[j - s[i][0]];
            else if(v1 == f[j])cnt[j] = (cnt[j] + cnt[j - s[i][0]]) % mod;
        }
    }
    return cnt[v] % mod;   
}

01背包求具体方案：
总价值最大且字典序最小的方案

const int N = 1100;
int dp[N][N], n, v, s[N][2];

void init(){
    cin >> n >> v;
    for(int i = 1; i <= n; i ++)cin >> s[i][0] >> s[i][1];
    for(int i = n; i >= 1; i --){
        for(int j = 0; j <= v; j ++){
            dp[i][j] = dp[i + 1][j];
            if(j >= s[i][0])dp[i][j] = max(dp[i][j], dp[i + 1][j - s[i][0]] + s[i][1]);
        }
    }
    int m = v;
    for(int i = 1; i <= n; i ++){
        if(m >= s[i][0] && dp[i][m] == dp[i + 1][m - s[i][0]] + s[i][1])cout << i << " ", m -= s[i][0];
    }
}
