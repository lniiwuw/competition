5.其他

5.1 高精度算法

高精度算法，数组存储：从低位-->高位
高精度加法，满足C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B){
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ ){
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

高精度减法，满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B){
    vector<int> c;
    
    for(int i = 0, t = 0; i < A.size(); i ++){
        t += A[i];
        if(i < B.size())t -= B[i];
        c.push_back((t + 10) % 10);
        if(t < 0)t = -1;
        else t = 0;
    }
    
    while(c.back() == 0 && c.size() > 1)c.pop_back();
    return c;
}

高精度乘法，高精度×低精度，// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b){
    vector<int> C;

    for (int i = 0, t = 0; i < A.size() || t; i ++ ){
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

高精度除法，高精度÷低精度，
A >= 0, b > 0, A除b余r
vector<int> div(vector<int> &A, int b, int &r){
    vector<int> C;  r = 0;
    
    for (int i = A.size() - 1; i >= 0; i -- ){
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}


5.2 差分矩阵

给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


5.3 排序

// 快速排序 O(n logn)
void quick_sort(int s[], int l, int r){
    if(l >= r)return ;
    
    int i = l - 1, j= r + 1, t = s[l + r >> 1];// 以区间中间的数为基准
    while(i < j){
        while(s[++ i] < t);
        while(s[-- j] > t);
        if(i < j)swap(s[i], s[j]);
    }
    
    quick_sort(s, l, j), quick_sort(s, j + 1, r);
}

// 归并排序 O(n logn)
void merge_sort(int s[], int l, int r){
    if(l >= r)return ;
    
    int mid = l + r >> 1;
    merge_sort(s, l, mid), merge_sort(s, mid + 1, r);
    
    int i = l,j = mid + 1, k = 0;
    while(i <= mid && j <= r){
        if(s[i] < s[j])p[++ k] =  s[i ++];
        else p[++ k] = s[j ++];
    }
    while(i <= mid )p[++ k] = s[i ++];
    while(j <= r)p[++ k] = s[j ++];
    
    for(i = l,j = 1;i <= r; i ++, j ++)s[i] = p[j];
}
